<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neural Network Visualizer - Academic Demo</title>
    <meta name="description" content="Academic demonstration of neural network visualization with simulated Rust/WASM computation and MaxGraph-style interactions">
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background: #f8f9fa;
            color: #2c3e50;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        .header {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .header h1 {
            color: #2c3e50;
            margin-bottom: 10px;
            font-size: 2.2em;
        }
        .header .subtitle {
            color: #7f8c8d;
            font-size: 16px;
            margin-bottom: 15px;
        }
        .header .tech-stack {
            display: flex;
            justify-content: center;
            gap: 20px;
            font-size: 12px;
            color: #95a5a6;
        }
        .controls {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            margin-bottom: 20px;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
        }
        .control-group h3 {
            margin: 0 0 12px 0;
            color: #34495e;
            font-size: 14px;
            font-weight: 600;
            border-bottom: 1px solid #ecf0f1;
            padding-bottom: 8px;
        }
        .control-group button {
            width: 100%;
            padding: 8px 12px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
            margin-bottom: 6px;
            transition: all 0.2s ease;
        }
        .btn-primary { background: #3498db; color: white; }
        .btn-primary:hover { background: #2980b9; transform: translateY(-1px); }
        .btn-success { background: #27ae60; color: white; }
        .btn-success:hover { background: #229954; transform: translateY(-1px); }
        .btn-warning { background: #f39c12; color: white; }
        .btn-warning:hover { background: #e67e22; transform: translateY(-1px); }
        .btn-danger { background: #e74c3c; color: white; }
        .btn-danger:hover { background: #c0392b; transform: translateY(-1px); }
        
        .graph-container {
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            overflow: hidden;
            height: 500px;
            position: relative;
            border: 1px solid #ecf0f1;
        }
        .neuron {
            position: absolute;
            width: 55px;
            height: 55px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 9px;
            color: white;
            cursor: move;
            user-select: none;
            box-shadow: 0 3px 10px rgba(0,0,0,0.15);
            border: 2px solid rgba(255,255,255,0.4);
            transition: transform 0.15s ease, box-shadow 0.15s ease;
        }
        .neuron:hover {
            transform: scale(1.08);
            box-shadow: 0 5px 15px rgba(0,0,0,0.25);
        }
        .neuron.dragging {
            transition: none !important;
            transform: none !important;
            z-index: 1000;
            cursor: grabbing;
        }
        .neuron.input { background: linear-gradient(135deg, #2ecc71, #27ae60); }
        .neuron.hidden { background: linear-gradient(135deg, #3498db, #2980b9); }
        .neuron.output { background: linear-gradient(135deg, #e67e22, #d35400); }
        
        /* Academic-style activation states */
        .neuron.processing { 
            background: linear-gradient(135deg, #9b59b6, #8e44ad);
            animation: academic-compute 1.2s ease-in-out;
        }
        .neuron.activated { 
            border: 2px solid #e74c3c;
            box-shadow: 0 0 12px rgba(231, 76, 60, 0.3);
        }
        
        @keyframes academic-compute {
            0%, 100% { transform: scale(1); }
            30% { transform: scale(1.03); opacity: 0.95; }
            70% { transform: scale(1.01); opacity: 0.98; }
        }
        
        .connection {
            position: absolute;
            height: 2px;
            background: #bdc3c7;
            transform-origin: left center;
            pointer-events: none;
            z-index: 1;
            transition: all 0.4s ease;
        }
        .connection.active { 
            background: linear-gradient(90deg, #e74c3c, #c0392b);
            height: 3px;
            box-shadow: 0 0 6px rgba(231, 76, 60, 0.4);
        }
        .connection.strong { 
            background: linear-gradient(90deg, #27ae60, #2ecc71);
            height: 3px;
        }
        .connection.weak { 
            background: #95a5a6;
            height: 1px;
        }
        
        .status-panel {
            background: #2c3e50;
            color: #ecf0f1;
            padding: 20px;
            border-radius: 8px;
            margin-top: 20px;
            font-family: 'SF Mono', 'Monaco', 'Inconsolata', 'Roboto Mono', monospace;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .status-panel h3 {
            margin: 0 0 15px 0;
            color: #ecf0f1;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .rust-log {
            background: #34495e;
            padding: 15px;
            border-radius: 6px;
            font-size: 11px;
            max-height: 180px;
            overflow-y: auto;
            color: #bdc3c7;
            border: 1px solid #4a5f7a;
        }
        .rust-log .info { color: #74b9ff; }
        .rust-log .success { color: #00b894; }
        .rust-log .warning { color: #fdcb6e; }
        .rust-log .error { color: #e17055; }
        .rust-log .compute { color: #a29bfe; }
        
        .github-info {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            margin-top: 20px;
            text-align: center;
        }
        .github-info h3 {
            color: #2c3e50;
            margin-bottom: 10px;
        }
        .github-info p {
            color: #7f8c8d;
            margin-bottom: 15px;
        }
        .github-info a {
            color: #3498db;
            text-decoration: none;
            font-weight: 600;
        }
        .github-info a:hover {
            text-decoration: underline;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üß† Neural Network Visualizer</h1>
            <p class="subtitle">Academic demonstration of neural network computation with MaxGraph-style visualization</p>
            <div class="tech-stack">
                <span>ü¶Ä Rust/WASM Simulation</span>
                <span>üìä MaxGraph Architecture</span>
                <span>üéØ Academic Focus</span>
                <span>‚ö° Interactive Learning</span>
            </div>
        </div>

        <div class="controls">
            <div class="control-group">
                <h3>üèóÔ∏è Network Architecture</h3>
                <button class="btn-primary" onclick="createNetwork()">Create Standard Network</button>
                <button class="btn-primary" onclick="addLayer()">Add Hidden Layer</button>
                <button class="btn-primary" onclick="optimizeLayout()">Optimize Layout</button>
                <button class="btn-primary" onclick="randomizeTopology()">Randomize Topology</button>
            </div>
            <div class="control-group">
                <h3>üéì Training & Inference</h3>
                <button class="btn-success" onclick="trainNetwork()">Train Network (5 epochs)</button>
                <button class="btn-warning" onclick="runInference()">Run Inference</button>
                <button class="btn-warning" onclick="runBackpropagation()">Backpropagation Pass</button>
                <button class="btn-success" onclick="batchTraining()">Batch Training</button>
            </div>
            <div class="control-group">
                <h3>üî¨ Analysis & Tools</h3>
                <button class="btn-primary" onclick="analyzeGradients()">Gradient Analysis</button>
                <button class="btn-primary" onclick="computeMetrics()">Compute Metrics</button>
                <button class="btn-success" onclick="exportWeights()">Export Model</button>
                <button class="btn-danger" onclick="resetNetwork()">Reset Network</button>
            </div>
        </div>

        <div class="graph-container" id="graphContainer"></div>

        <div class="status-panel">
            <h3>ü¶Ä Rust Neural Engine Console</h3>
            <div class="rust-log" id="rustLog">
                <div class="info">[INFO] Neural network visualizer initialized - academic mode</div>
                <div class="success">[SUCCESS] WASM computation engine ready</div>
                <div class="info">[INFO] MaxGraph-style interaction layer active</div>
            </div>
        </div>

        <div class="github-info">
            <h3>üìö Academic Neural Network Demonstration</h3>
            <p>This visualization demonstrates core neural network concepts with simulated Rust/WASM computation. 
            Drag neurons to reorganize the network, observe training dynamics, and explore gradient flow.</p>
            <p><strong>Features:</strong> Forward propagation, backpropagation, gradient visualization, weight analysis, and interactive network topology editing.</p>
            <p><a href="https://github.com/yourusername/neural-visualizer" target="_blank">View Source Code on GitHub</a></p>
        </div>
    </div>

    <script>
        // Neural network state
        let neurons = new Map();
        let connections = [];
        let neuronCounter = 1;
        let isDragging = false;
        let dragStart = { x: 0, y: 0 };
        let isTraining = false;
        let currentEpoch = 0;
        let trainingMetrics = { loss: 0, accuracy: 0 };
        
        // Academic Rust/WASM simulation
        const AcademicNeuralEngine = {
            forwardPass: async function(networkData) {
                logRust('compute', `[FORWARD] Processing ${networkData.neurons || neurons.size} neurons, ${networkData.connections || connections.length} connections`);
                
                return new Promise((resolve) => {
                    const computeTime = 600 + Math.random() * 400;
                    setTimeout(() => {
                        const loss = Math.random() * 0.15 + 0.05;
                        const accuracy = 0.75 + Math.random() * 0.2;
                        trainingMetrics = { loss, accuracy };
                        
                        logRust('success', `[FORWARD] Complete. Loss: ${loss.toFixed(4)}, Accuracy: ${accuracy.toFixed(3)}`);
                        resolve({ loss, accuracy, predictions: Array(3).fill().map(() => Math.random()) });
                    }, computeTime);
                });
            },
            
            backpropagate: async function(targetOutputs) {
                logRust('compute', `[BACKPROP] Computing gradients via chain rule`);
                
                return new Promise((resolve) => {
                    setTimeout(() => {
                        const gradients = connections.map(() => (Math.random() - 0.5) * 0.02);
                        const maxGrad = Math.max(...gradients.map(Math.abs));
                        const meanGrad = gradients.reduce((a,b) => a + Math.abs(b), 0) / gradients.length;
                        
                        logRust('success', `[BACKPROP] Gradients computed. Max: ${maxGrad.toFixed(6)}, Mean: ${meanGrad.toFixed(6)}`);
                        resolve(gradients);
                    }, 500 + Math.random() * 300);
                });
            },
            
            updateWeights: async function(gradients, learningRate = 0.01) {
                logRust('info', `[UPDATE] Applying SGD with Œ∑=${learningRate}`);
                
                return new Promise((resolve) => {
                    setTimeout(() => {
                        const updatedWeights = connections.map((conn, i) => {
                            const currentWeight = conn.weight || (Math.random() * 2 - 1);
                            return currentWeight - learningRate * (gradients[i] || 0);
                        });
                        
                        const weightNorm = Math.sqrt(updatedWeights.reduce((sum, w) => sum + w*w, 0));
                        logRust('success', `[UPDATE] Weights updated. L2 norm: ${weightNorm.toFixed(4)}`);
                        resolve(updatedWeights);
                    }, 300);
                });
            },
            
            analyzeNetwork: async function() {
                logRust('compute', `[ANALYSIS] Computing network statistics`);
                
                return new Promise((resolve) => {
                    setTimeout(() => {
                        const analysis = {
                            parameters: connections.length + neurons.size,
                            flops: connections.length * 2 + neurons.size,
                            memory: (neurons.size * 32 + connections.length * 64) / 8 / 1024, // KB
                            sparsity: connections.filter(c => Math.abs(c.weight || 0) < 0.1).length / connections.length,
                            efficiency: 0.7 + Math.random() * 0.25
                        };
                        
                        logRust('success', `[ANALYSIS] Parameters: ${analysis.parameters}, FLOPs: ${analysis.flops}, Memory: ${analysis.memory.toFixed(1)}KB`);
                        logRust('info', `[ANALYSIS] Sparsity: ${(analysis.sparsity * 100).toFixed(1)}%, Efficiency: ${(analysis.efficiency * 100).toFixed(1)}%`);
                        resolve(analysis);
                    }, 400);
                });
            }
        };

        function initializeDemo() {
            const container = document.getElementById('graphContainer');
            container.addEventListener('mousedown', handleMouseDown);
            container.addEventListener('mousemove', handleMouseMove);
            container.addEventListener('mouseup', handleMouseUp);
            container.addEventListener('mouseleave', handleMouseUp);
            
            createNetwork();
            logRust('success', '[INIT] Academic neural network demonstration ready');
        }

        function createNetwork() {
            clearNetwork();
            
            // Create standard 3-2-1 architecture
            const input1 = createNeuron('input', 100, 180, 'x‚ÇÅ');
            const input2 = createNeuron('input', 100, 230, 'x‚ÇÇ');
            const input3 = createNeuron('input', 100, 280, 'x‚ÇÉ');
            
            const hidden1 = createNeuron('hidden', 280, 205, 'h‚ÇÅ');
            const hidden2 = createNeuron('hidden', 280, 255, 'h‚ÇÇ');
            
            const output1 = createNeuron('output', 460, 230, '≈∑');
            
            // Create weighted connections
            const inputNeurons = [input1, input2, input3];
            const hiddenNeurons = [hidden1, hidden2];
            const outputNeurons = [output1];
            
            // Input to hidden connections
            inputNeurons.forEach(input => {
                hiddenNeurons.forEach(hidden => {
                    createConnection(input, hidden, (Math.random() * 2 - 1) * 0.8);
                });
            });
            
            // Hidden to output connections
            hiddenNeurons.forEach(hidden => {
                outputNeurons.forEach(output => {
                    createConnection(hidden, output, (Math.random() * 2 - 1) * 0.8);
                });
            });
            
            logRust('info', `[NETWORK] Created ${inputNeurons.length}-${hiddenNeurons.length}-${outputNeurons.length} feedforward architecture`);
        }

        function createNeuron(type, x, y, label) {
            const neuron = document.createElement('div');
            neuron.className = `neuron ${type}`;
            neuron.style.left = x + 'px';
            neuron.style.top = y + 'px';
            neuron.textContent = label;
            neuron.dataset.id = `n${neuronCounter++}`;
            neuron.dataset.type = type;
            
            document.getElementById('graphContainer').appendChild(neuron);
            
            const neuronData = {
                id: neuron.dataset.id,
                element: neuron,
                type: type,
                x: x,
                y: y,
                label: label,
                activation: 0,
                bias: (Math.random() - 0.5) * 0.2
            };
            
            neurons.set(neuron.dataset.id, neuronData);
            return neuronData;
        }

        function createConnection(source, target, weight) {
            const connection = document.createElement('div');
            connection.className = 'connection';
            
            // Academic weight visualization
            if (Math.abs(weight) > 0.5) connection.classList.add('strong');
            else if (Math.abs(weight) < 0.2) connection.classList.add('weak');
            
            updateConnectionPosition(connection, source, target);
            document.getElementById('graphContainer').appendChild(connection);
            
            connections.push({
                element: connection,
                source: source,
                target: target,
                weight: weight
            });
        }

        function updateConnectionPosition(connectionElement, source, target) {
            const startX = source.x + 27.5;
            const startY = source.y + 27.5;
            const endX = target.x + 27.5;
            const endY = target.y + 27.5;
            
            const distance = Math.sqrt(Math.pow(endX - startX, 2) + Math.pow(endY - startY, 2));
            const angle = Math.atan2(endY - startY, endX - startX) * 180 / Math.PI;
            
            connectionElement.style.left = startX + 'px';
            connectionElement.style.top = startY + 'px';
            connectionElement.style.width = distance + 'px';
            connectionElement.style.transform = `rotate(${angle}deg)`;
        }

        async function trainNetwork() {
            if (isTraining) return;
            
            isTraining = true;
            logRust('info', '[TRAIN] Initiating supervised learning protocol');
            
            const epochs = 5;
            for (let epoch = 1; epoch <= epochs; epoch++) {
                currentEpoch = epoch;
                logRust('info', `[TRAIN] Epoch ${epoch}/${epochs} - Forward pass`);
                
                // Forward pass with visualization
                await simulateAcademicForwardPass();
                const result = await AcademicNeuralEngine.forwardPass({ neurons: neurons.size, connections: connections.length });
                
                await new Promise(resolve => setTimeout(resolve, 200));
                
                // Backward pass with visualization
                logRust('info', `[TRAIN] Epoch ${epoch}/${epochs} - Backward pass`);
                await simulateAcademicBackwardPass();
                const gradients = await AcademicNeuralEngine.backpropagate([]);
                
                // Weight updates
                const updatedWeights = await AcademicNeuralEngine.updateWeights(gradients, 0.01);
                updateConnectionWeights(updatedWeights);
                
                await new Promise(resolve => setTimeout(resolve, 300));
                
                // Log progress
                logRust('success', `[TRAIN] Epoch ${epoch} complete. Loss: ${result.loss.toFixed(4)}`);
            }
            
            isTraining = false;
            logRust('success', `[TRAIN] Training complete after ${epochs} epochs. Final loss: ${trainingMetrics.loss.toFixed(4)}`);
        }

        async function simulateAcademicForwardPass() {
            const neuronList = Array.from(neurons.values());
            const layers = [
                neuronList.filter(n => n.type === 'input'),
                neuronList.filter(n => n.type === 'hidden'),
                neuronList.filter(n => n.type === 'output')
            ];
            
            for (let layerIndex = 0; layerIndex < layers.length; layerIndex++) {
                const layer = layers[layerIndex];
                
                for (let i = 0; i < layer.length; i++) {
                    layer[i].element.classList.add('processing');
                    await new Promise(resolve => setTimeout(resolve, 150));
                    layer[i].element.classList.remove('processing');
                    layer[i].element.classList.add('activated');
                    
                    // Activate outgoing connections
                    if (layerIndex < layers.length - 1) {
                        connections.filter(c => c.source === layer[i]).forEach(conn => {
                            conn.element.classList.add('active');
                        });
                    }
                }
                
                await new Promise(resolve => setTimeout(resolve, 200));
            }
        }

        async function simulateAcademicBackwardPass() {
            const neuronList = Array.from(neurons.values());
            const layers = [
                neuronList.filter(n => n.type === 'output'),
                neuronList.filter(n => n.type === 'hidden'),
                neuronList.filter(n => n.type === 'input')
            ];
            
            // Backward through layers
            for (const layer of layers) {
                for (const neuron of layer) {
                    neuron.element.classList.add('processing');
                    await new Promise(resolve => setTimeout(resolve, 120));
                    neuron.element.classList.remove('processing');
                }
                await new Promise(resolve => setTimeout(resolve, 150));
            }
            
            // Clear activation states
            setTimeout(() => {
                neurons.forEach(neuron => {
                    neuron.element.classList.remove('activated');
                });
                connections.forEach(conn => {
                    conn.element.classList.remove('active');
                });
            }, 400);
        }

        function updateConnectionWeights(newWeights) {
            connections.forEach((conn, i) => {
                if (i < newWeights.length) {
                    conn.weight = newWeights[i];
                    
                    // Update visual representation
                    conn.element.classList.remove('strong', 'weak');
                    if (Math.abs(conn.weight) > 0.5) {
                        conn.element.classList.add('strong');
                    } else if (Math.abs(conn.weight) < 0.2) {
                        conn.element.classList.add('weak');
                    }
                }
            });
        }

        async function runInference() {
            logRust('info', '[INFERENCE] Running forward pass for prediction');
            await simulateAcademicForwardPass();
            
            const result = await AcademicNeuralEngine.forwardPass({});
            const confidence = 0.75 + Math.random() * 0.2;
            
            logRust('success', `[INFERENCE] Prediction complete. Output: [${result.predictions.map(p => p.toFixed(3)).join(', ')}]`);
            logRust('info', `[INFERENCE] Confidence: ${confidence.toFixed(3)}`);
        }

        async function runBackpropagation() {
            logRust('info', '[BACKPROP] Running isolated backpropagation pass');
            await simulateAcademicBackwardPass();
            await AcademicNeuralEngine.backpropagate([]);
        }

        async function analyzeGradients() {
            const analysis = await AcademicNeuralEngine.analyzeNetwork();
            logRust('info', `[GRADIENT] Mean gradient norm: ${(Math.random() * 0.01).toFixed(6)}`);
            logRust('info', `[GRADIENT] Gradient sparsity: ${(analysis.sparsity * 100).toFixed(1)}%`);
        }

        async function computeMetrics() {
            logRust('compute', '[METRICS] Computing performance metrics');
            
            setTimeout(() => {
                const metrics = {
                    trainLoss: trainingMetrics.loss,
                    valLoss: trainingMetrics.loss * (1 + Math.random() * 0.1),
                    trainAcc: trainingMetrics.accuracy,
                    valAcc: trainingMetrics.accuracy * (0.95 + Math.random() * 0.05)
                };
                
                logRust('success', `[METRICS] Train Loss: ${metrics.trainLoss.toFixed(4)}, Val Loss: ${metrics.valLoss.toFixed(4)}`);
                logRust('success', `[METRICS] Train Acc: ${metrics.trainAcc.toFixed(3)}, Val Acc: ${metrics.valAcc.toFixed(3)}`);
            }, 300);
        }

        async function batchTraining() {
            logRust('info', '[BATCH] Running mini-batch training (batch_size=32)');
            
            for (let batch = 1; batch <= 3; batch++) {
                logRust('info', `[BATCH] Processing batch ${batch}/3`);
                await simulateAcademicForwardPass();
                await new Promise(resolve => setTimeout(resolve, 200));
                await simulateAcademicBackwardPass();
                await new Promise(resolve => setTimeout(resolve, 200));
            }
            
            logRust('success', '[BATCH] Mini-batch training complete');
        }

        function exportWeights() {
            const weightData = {
                architecture: `${Array.from(neurons.values()).filter(n => n.type === 'input').length}-${Array.from(neurons.values()).filter(n => n.type === 'hidden').length}-${Array.from(neurons.values()).filter(n => n.type === 'output').length}`,
                weights: connections.map(c => c.weight.toFixed(6)),
                biases: Array.from(neurons.values()).map(n => n.bias.toFixed(6)),
                timestamp: new Date().toISOString()
            };
            
            logRust('success', `[EXPORT] Model exported: ${weightData.weights.length} weights, ${weightData.biases.length} biases`);
            logRust('info', `[EXPORT] Architecture: ${weightData.architecture}`);
        }

        function addLayer() {
            const hiddenNeurons = Array.from(neurons.values()).filter(n => n.type === 'hidden');
            const newX = 200 + hiddenNeurons.length * 80;
            const newY = 200 + (Math.random() - 0.5) * 100;
            
            createNeuron('hidden', newX, newY, `h${hiddenNeurons.length + 1}`);
            logRust('info', `[ARCHITECTURE] Added hidden layer neuron h${hiddenNeurons.length + 1}`);
        }

        function optimizeLayout() {
            const neuronList = Array.from(neurons.values());
            const layers = {
                input: neuronList.filter(n => n.type === 'input'),
                hidden: neuronList.filter(n => n.type === 'hidden'),
                output: neuronList.filter(n => n.type === 'output')
            };
            
            let currentX = 100;
            Object.entries(layers).forEach(([layerType, layer]) => {
                if (layer.length > 0) {
                    const centerY = 250;
                    const spacing = Math.min(60, 300 / Math.max(1, layer.length - 1));
                    const startY = centerY - (layer.length - 1) * spacing / 2;
                    
                    layer.forEach((neuron, i) => {
                        neuron.x = currentX;
                        neuron.y = startY + i * spacing;
                        neuron.element.style.left = neuron.x + 'px';
                        neuron.element.style.top = neuron.y + 'px';
                    });
                    
                    currentX += 180;
                }
            });
            
            // Update all connections
            connections.forEach(conn => {
                updateConnectionPosition(conn.element, conn.source, conn.target);
            });
            
            logRust('info', '[LAYOUT] Network topology optimized for academic visualization');
        }

        function randomizeTopology() {
            const container = document.getElementById('graphContainer');
            const containerRect = container.getBoundingClientRect();
            
            neurons.forEach(neuron => {
                neuron.x = 50 + Math.random() * (containerRect.width - 150);
                neuron.y = 50 + Math.random() * (containerRect.height - 150);
                neuron.element.style.left = neuron.x + 'px';
                neuron.element.style.top = neuron.y + 'px';
            });
            
            connections.forEach(conn => {
                updateConnectionPosition(conn.element, conn.source, conn.target);
            });
            
            logRust('info', '[TOPOLOGY] Network layout randomized for exploration');
        }

        function resetNetwork() {
            clearNetwork();
            logRust('warning', '[RESET] Network state cleared - ready for new architecture');
        }

        function clearNetwork() {
            document.getElementById('graphContainer').innerHTML = '';
            neurons.clear();
            connections = [];
            neuronCounter = 1;
            isTraining = false;
            currentEpoch = 0;
        }

        function logRust(level, message) {
            const log = document.getElementById('rustLog');
            const entry = document.createElement('div');
            entry.className = level;
            entry.textContent = `${new Date().toLocaleTimeString('en-US', { hour12: false })} ${message}`;
            log.appendChild(entry);
            log.scrollTop = log.scrollHeight;
            
            // Keep log manageable (max 100 entries)
            if (log.children.length > 100) {
                log.removeChild(log.firstChild);
            }
        }

        // Academic-grade drag and drop
        function handleMouseDown(e) {
            const neuron = e.target.closest('.neuron');
            if (neuron) {
                isDragging = true;
                const rect = document.getElementById('graphContainer').getBoundingClientRect();
                dragStart = { 
                    x: e.clientX - rect.left, 
                    y: e.clientY - rect.top,
                    neuron: neuron
                };
                neuron.classList.add('dragging');
                e.preventDefault();
            }
        }

        function handleMouseMove(e) {
            if (isDragging && dragStart.neuron) {
                const rect = document.getElementById('graphContainer').getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                const neuronData = neurons.get(dragStart.neuron.dataset.id);
                if (neuronData) {
                    const deltaX = x - dragStart.x;
                    const deltaY = y - dragStart.y;
                    
                    neuronData.x += deltaX;
                    neuronData.y += deltaY;
                    
                    // Constrain to container
                    neuronData.x = Math.max(10, Math.min(neuronData.x, rect.width - 65));
                    neuronData.y = Math.max(10, Math.min(neuronData.y, rect.height - 65));
                    
                    dragStart.neuron.style.left = neuronData.x + 'px';
                    dragStart.neuron.style.top = neuronData.y + 'px';
                    
                    // Update connected connections
                    connections.forEach(conn => {
                        if (conn.source === neuronData || conn.target === neuronData) {
                            updateConnectionPosition(conn.element, conn.source, conn.target);
                        }
                    });
                    
                    dragStart.x = x;
                    dragStart.y = y;
                }
            }
        }

        function handleMouseUp(e) {
            if (isDragging) {
                isDragging = false;
                if (dragStart.neuron) {
                    dragStart.neuron.classList.remove('dragging');
                    dragStart.neuron = null;
                }
            }
        }

        // Initialize
        document.addEventListener('DOMContentLoaded', initializeDemo);
    </script>
</body>
</html>
