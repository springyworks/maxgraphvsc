<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pure MaxGraph Neural Network Demo</title>
    <script type="module">
        import { Graph, Cell, Geometry, ConnectionHandler, RubberBandHandler, PanningHandler, HierarchicalLayout, CircleLayout, FastOrganicLayout } from './node_modules/@maxgraph/core/lib/esm/index.js';
        
        // Keep the script content but move it to after the imports
        window.maxGraphLoaded = true;
    </script>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background: #f5f5f5;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        .header {
            text-align: center;
            margin-bottom: 30px;
        }
        .controls {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            margin-bottom: 20px;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            align-items: center;
        }
        .controls button {
            padding: 10px 16px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: background 0.3s ease;
        }
        .controls button:hover {
            background: #45a049;
        }
        .controls button.secondary {
            background: #2196F3;
        }
        .controls button.secondary:hover {
            background: #1976D2;
        }
        .controls button.danger {
            background: #f44336;
        }
        .controls button.danger:hover {
            background: #d32f2f;
        }
        .status {
            background: #e8f5e8;
            padding: 10px;
            border-radius: 4px;
            margin-left: auto;
            font-weight: bold;
            color: #2e7d32;
        }
        .graph-container {
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            overflow: hidden;
            height: 600px;
            position: relative;
        }
        .info-panel {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            margin-top: 20px;
        }
        .info-panel h3 {
            margin-top: 0;
            color: #333;
        }
        .info-panel ul {
            margin: 10px 0;
            padding-left: 20px;
        }
        .info-panel li {
            margin: 5px 0;
        }
        .feature-highlight {
            background: #f0f7ff;
            padding: 10px;
            border-left: 4px solid #2196F3;
            margin: 10px 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üöÄ Pure MaxGraph Neural Network Demo</h1>
            <p>Full MaxGraph power - professional graph engine with built-in interactions</p>
        </div>

        <div class="controls">
            <button onclick="addInputNeuron()">Add Input Neuron</button>
            <button onclick="addHiddenNeuron()">Add Hidden Neuron</button>
            <button onclick="addOutputNeuron()">Add Output Neuron</button>
            <button onclick="connectNeurons()" class="secondary">Auto Connect</button>
            <button onclick="runHierarchicalLayout()" class="secondary">Hierarchical Layout</button>
            <button onclick="runCircularLayout()" class="secondary">Circular Layout</button>
            <button onclick="runOrganicLayout()" class="secondary">Organic Layout</button>
            <button onclick="toggleRubberBand()" class="secondary">Toggle Rubber Band</button>
            <button onclick="animateActivation()" class="secondary">Animate Forward Pass</button>
            <button onclick="clearGraph()" class="danger">Clear Graph</button>
            <div class="status" id="status">‚úÖ Pure MaxGraph Ready - Drag, select, rubber band!</div>
        </div>

        <div class="graph-container" id="graphContainer"></div>

        <div class="info-panel">
            <h3>üéØ Pure MaxGraph Features in Action</h3>
            <div class="feature-highlight">
                <strong>What you can do:</strong>
                <ul>
                    <li>üñ±Ô∏è <strong>Drag nodes</strong>: Click and drag any neuron to move it</li>
                    <li>üì¶ <strong>Rubber band selection</strong>: Drag in empty space to select multiple nodes</li>
                    <li>üîó <strong>Edge routing</strong>: Connections automatically route around obstacles</li>
                    <li>üìê <strong>Professional layouts</strong>: Hierarchical, circular, and organic algorithms</li>
                    <li>‚ö° <strong>Built-in interactions</strong>: Zoom, pan, select - all handled by MaxGraph</li>
                    <li>üé® <strong>Custom styling</strong>: Neural-specific colors and shapes via MaxGraph styles</li>
                    <li>üì± <strong>Touch support</strong>: Works on mobile devices</li>
                    <li>‚öôÔ∏è <strong>Event system</strong>: Professional event handling and callbacks</li>
                </ul>
            </div>
            
            <div class="feature-highlight">
                <strong>MaxGraph vs Hybrid Approach:</strong>
                <ul>
                    <li>‚úÖ <strong>Single coordinate system</strong> - no more dual-world complexity</li>
                    <li>‚úÖ <strong>Built-in rubber band</strong> - professional multi-select out of the box</li>
                    <li>‚úÖ <strong>Mature edge routing</strong> - connections look professional</li>
                    <li>‚úÖ <strong>Undo/Redo support</strong> - built into the framework</li>
                    <li>‚úÖ <strong>Export/Import</strong> - save and load graph structures</li>
                    <li>‚úÖ <strong>Performance optimized</strong> - handles large graphs efficiently</li>
                </ul>
            </div>

            <p><strong>üß† Neural Network Integration:</strong> This pure MaxGraph approach can still connect to your Rust/WASM backend for neural computations, but with a much simpler integration surface - just sync the graph structure and node states!</p>
        </div>
    </div>

    <script>
        const { Graph, Cell, Geometry, ConnectionHandler, RubberBandHandler, PanningHandler } = maxGraph;
        
        let graph;
        let rubberBandEnabled = true;
        let neuronCounter = 1;
        
        // Initialize MaxGraph
        function initializeMaxGraph() {
            const container = document.getElementById('graphContainer');
            
            // Create graph
            graph = new Graph(container);
            
            // Enable various handlers
            graph.setConnectable(true);
            graph.setDisconnectOnMove(false);
            graph.setDropEnabled(true);
            
            // Enable rubber band selection
            new RubberBandHandler(graph);
            
            // Enable panning
            new PanningHandler(graph);
            
            // Allow connections
            graph.connectionHandler.setCreateTarget(true);
            
            // Style the graph
            setupStyles();
            
            // Add event listeners
            setupEventListeners();
            
            // Create initial demo network
            createInitialNetwork();
            
            console.log('‚úÖ Pure MaxGraph initialized');
            updateStatus('Pure MaxGraph initialized - try dragging and rubber band selection!');
        }
        
        function setupStyles() {
            const stylesheet = graph.getStylesheet();
            
            // Input neuron style
            stylesheet.putCellStyle('inputNeuron', {
                shape: 'ellipse',
                fillColor: '#4CAF50',
                strokeColor: '#2E7D32',
                strokeWidth: 3,
                fontColor: 'white',
                fontSize: 12,
                fontStyle: 'bold'
            });
            
            // Hidden neuron style  
            stylesheet.putCellStyle('hiddenNeuron', {
                shape: 'ellipse',
                fillColor: '#2196F3',
                strokeColor: '#1565C0',
                strokeWidth: 3,
                fontColor: 'white',
                fontSize: 12,
                fontStyle: 'bold'
            });
            
            // Output neuron style
            stylesheet.putCellStyle('outputNeuron', {
                shape: 'ellipse',
                fillColor: '#FF5722',
                strokeColor: '#D84315',
                strokeWidth: 3,
                fontColor: 'white',
                fontSize: 12,
                fontStyle: 'bold'
            });
            
            // Neural connection style
            stylesheet.putCellStyle('neuralConnection', {
                strokeColor: '#666',
                strokeWidth: 2,
                endArrow: 'classic',
                endSize: 8,
                rounded: true
            });
            
            // Activated neuron style
            stylesheet.putCellStyle('activatedNeuron', {
                shape: 'ellipse',
                fillColor: '#FFD700',
                strokeColor: '#FF8F00',
                strokeWidth: 4,
                fontColor: '#333',
                fontSize: 12,
                fontStyle: 'bold',
                shadow: true
            });
        }
        
        function setupEventListeners() {
            // Listen for cell selection
            graph.getSelectionModel().addListener('change', function(sender, evt) {
                const cells = graph.getSelectionCells();
                if (cells.length > 0) {
                    updateStatus(`Selected ${cells.length} item(s) - try rubber band selection!`);
                }
            });
            
            // Listen for cell movement
            graph.addListener('cellsMoved', function(sender, evt) {
                updateStatus('Cells moved - MaxGraph handles all positioning!');
            });
            
            // Listen for connections
            graph.addListener('connect', function(sender, evt) {
                const edge = evt.getProperty('cell');
                edge.setStyle('neuralConnection');
                updateStatus('Neural connection created!');
            });
        }
        
        function createInitialNetwork() {
            const parent = graph.getDefaultParent();
            
            graph.getModel().beginUpdate();
            try {
                // Create input layer
                const input1 = graph.insertVertex(parent, null, 'Input 1', 50, 100, 80, 50, 'inputNeuron');
                const input2 = graph.insertVertex(parent, null, 'Input 2', 50, 200, 80, 50, 'inputNeuron');
                const input3 = graph.insertVertex(parent, null, 'Input 3', 50, 300, 80, 50, 'inputNeuron');
                
                // Create hidden layer
                const hidden1 = graph.insertVertex(parent, null, 'Hidden 1', 250, 150, 80, 50, 'hiddenNeuron');
                const hidden2 = graph.insertVertex(parent, null, 'Hidden 2', 250, 250, 80, 50, 'hiddenNeuron');
                
                // Create output layer
                const output1 = graph.insertVertex(parent, null, 'Output', 450, 200, 80, 50, 'outputNeuron');
                
                // Create connections
                graph.insertEdge(parent, null, '0.8', input1, hidden1, 'neuralConnection');
                graph.insertEdge(parent, null, '0.3', input1, hidden2, 'neuralConnection');
                graph.insertEdge(parent, null, '-0.5', input2, hidden1, 'neuralConnection');
                graph.insertEdge(parent, null, '0.7', input2, hidden2, 'neuralConnection');
                graph.insertEdge(parent, null, '0.2', input3, hidden1, 'neuralConnection');
                graph.insertEdge(parent, null, '-0.3', input3, hidden2, 'neuralConnection');
                graph.insertEdge(parent, null, '0.9', hidden1, output1, 'neuralConnection');
                graph.insertEdge(parent, null, '0.4', hidden2, output1, 'neuralConnection');
                
            } finally {
                graph.getModel().endUpdate();
            }
            
            updateStatus('Initial neural network created - try dragging nodes or rubber band selection!');
        }
        
        function addInputNeuron() {
            const parent = graph.getDefaultParent();
            const x = 50 + Math.random() * 100;
            const y = 50 + Math.random() * 400;
            
            graph.getModel().beginUpdate();
            try {
                graph.insertVertex(parent, null, `Input ${neuronCounter++}`, x, y, 80, 50, 'inputNeuron');
            } finally {
                graph.getModel().endUpdate();
            }
            
            updateStatus('Input neuron added - drag it around!');
        }
        
        function addHiddenNeuron() {
            const parent = graph.getDefaultParent();
            const x = 200 + Math.random() * 150;
            const y = 50 + Math.random() * 400;
            
            graph.getModel().beginUpdate();
            try {
                graph.insertVertex(parent, null, `Hidden ${neuronCounter++}`, x, y, 80, 50, 'hiddenNeuron');
            } finally {
                graph.getModel().endUpdate();
            }
            
            updateStatus('Hidden neuron added - try connecting it to others!');
        }
        
        function addOutputNeuron() {
            const parent = graph.getDefaultParent();
            const x = 400 + Math.random() * 100;
            const y = 50 + Math.random() * 400;
            
            graph.getModel().beginUpdate();
            try {
                graph.insertVertex(parent, null, `Output ${neuronCounter++}`, x, y, 80, 50, 'outputNeuron');
            } finally {
                graph.getModel().endUpdate();
            }
            
            updateStatus('Output neuron added - ready for predictions!');
        }
        
        function connectNeurons() {
            const cells = graph.getChildVertices(graph.getDefaultParent());
            const parent = graph.getDefaultParent();
            
            if (cells.length < 2) {
                updateStatus('Need at least 2 neurons to connect!');
                return;
            }
            
            graph.getModel().beginUpdate();
            try {
                // Connect some random neurons
                for (let i = 0; i < Math.min(5, cells.length - 1); i++) {
                    const source = cells[Math.floor(Math.random() * cells.length)];
                    const target = cells[Math.floor(Math.random() * cells.length)];
                    
                    if (source !== target) {
                        const weight = (Math.random() * 2 - 1).toFixed(2);
                        graph.insertEdge(parent, null, weight, source, target, 'neuralConnection');
                    }
                }
            } finally {
                graph.getModel().endUpdate();
            }
            
            updateStatus('Neurons connected - MaxGraph handles all the edge routing!');
        }
        
        function runHierarchicalLayout() {
            const { HierarchicalLayout } = maxGraph;
            const layout = new HierarchicalLayout(graph);
            layout.orientation = 'west';
            layout.execute(graph.getDefaultParent());
            updateStatus('Hierarchical layout applied - perfect for neural networks!');
        }
        
        function runCircularLayout() {
            const { CircleLayout } = maxGraph;
            const layout = new CircleLayout(graph);
            layout.execute(graph.getDefaultParent());
            updateStatus('Circular layout applied - see the network structure!');
        }
        
        function runOrganicLayout() {
            const { FastOrganicLayout } = maxGraph;
            const layout = new FastOrganicLayout(graph);
            layout.execute(graph.getDefaultParent());
            updateStatus('Organic layout applied - naturally distributed neurons!');
        }
        
        function toggleRubberBand() {
            rubberBandEnabled = !rubberBandEnabled;
            graph.setEnabled(rubberBandEnabled);
            updateStatus(`Rubber band selection ${rubberBandEnabled ? 'enabled' : 'disabled'} - try dragging in empty space!`);
        }
        
        function animateActivation() {
            const cells = graph.getChildVertices(graph.getDefaultParent());
            const inputCells = cells.filter(cell => cell.getStyle().includes('inputNeuron'));
            
            if (inputCells.length === 0) {
                updateStatus('No input neurons to activate!');
                return;
            }
            
            updateStatus('Animating forward pass through the network...');
            
            // Activate input neurons first
            inputCells.forEach((cell, index) => {
                setTimeout(() => {
                    graph.setCellStyle('activatedNeuron', [cell]);
                    
                    // Reset after animation
                    setTimeout(() => {
                        graph.setCellStyle('inputNeuron', [cell]);
                    }, 1000);
                }, index * 200);
            });
            
            // Then hidden and output neurons
            setTimeout(() => {
                const hiddenCells = cells.filter(cell => cell.getStyle().includes('hiddenNeuron'));
                hiddenCells.forEach((cell, index) => {
                    setTimeout(() => {
                        graph.setCellStyle('activatedNeuron', [cell]);
                        setTimeout(() => {
                            graph.setCellStyle('hiddenNeuron', [cell]);
                        }, 1000);
                    }, index * 100);
                });
            }, 800);
            
            setTimeout(() => {
                const outputCells = cells.filter(cell => cell.getStyle().includes('outputNeuron'));
                outputCells.forEach((cell, index) => {
                    setTimeout(() => {
                        graph.setCellStyle('activatedNeuron', [cell]);
                        setTimeout(() => {
                            graph.setCellStyle('outputNeuron', [cell]);
                        }, 1000);
                    }, index * 100);
                });
            }, 1500);
        }
        
        function clearGraph() {
            graph.getModel().beginUpdate();
            try {
                graph.removeCells(graph.getChildVertices(graph.getDefaultParent()));
                graph.removeCells(graph.getChildEdges(graph.getDefaultParent()));
            } finally {
                graph.getModel().endUpdate();
            }
            
            neuronCounter = 1;
            updateStatus('Graph cleared - start building your neural network!');
        }
        
        function updateStatus(message) {
            document.getElementById('status').textContent = message;
        }
        
        // Initialize when page loads
        document.addEventListener('DOMContentLoaded', function() {
            initializeMaxGraph();
        });
    </script>
</body>
</html>
