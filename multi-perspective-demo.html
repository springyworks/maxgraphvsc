<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üß† Multi-Perspective Neural Network Visualizer</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            margin: 0;
            padding: 0;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            min-height: 100vh;
        }
        
        .header {
            text-align: center;
            padding: 1.5rem;
            background: rgba(0,0,0,0.1);
            backdrop-filter: blur(10px);
        }
        
        .perspective-tabs {
            display: flex;
            justify-content: center;
            gap: 1rem;
            margin: 1rem auto;
            max-width: 800px;
            flex-wrap: wrap;
        }
        
        .tab {
            background: rgba(255,255,255,0.1);
            border: 2px solid rgba(255,255,255,0.2);
            color: white;
            padding: 0.75rem 1.5rem;
            border-radius: 25px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 500;
        }
        
        .tab.active {
            background: rgba(255,255,255,0.3);
            border-color: #4fd1c7;
            box-shadow: 0 0 20px rgba(79, 209, 199, 0.3);
            transform: translateY(-2px);
        }
        
        .tab:hover:not(.active) {
            background: rgba(255,255,255,0.2);
            transform: translateY(-1px);
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 0 1rem;
        }
        
        .visualization-container {
            position: relative;
            background: rgba(255,255,255,0.1);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 2rem;
            margin: 1rem auto;
            border: 1px solid rgba(255,255,255,0.2);
            min-height: 600px;
        }
        
        .layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            opacity: 0;
            transition: opacity 0.5s ease;
            pointer-events: none;
        }
        
        .layer.active {
            opacity: 1;
            pointer-events: all;
        }
        
        #graph-container {
            width: 100%;
            height: 500px;
            border: 2px solid rgba(255,255,255,0.3);
            border-radius: 12px;
            background: white;
            position: relative;
            overflow: hidden;
        }
        
        .controls {
            display: flex;
            gap: 1rem;
            margin: 1rem 0;
            flex-wrap: wrap;
            justify-content: center;
        }
        
        button {
            background: rgba(255,255,255,0.2);
            border: 1px solid rgba(255,255,255,0.3);
            color: white;
            padding: 0.75rem 1.5rem;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.3s ease;
        }
        
        button:hover {
            background: rgba(255,255,255,0.3);
            transform: translateY(-2px);
        }
        
        .layer-info {
            position: absolute;
            top: 1rem;
            left: 1rem;
            background: rgba(0,0,0,0.8);
            padding: 1rem;
            border-radius: 8px;
            font-size: 0.9rem;
            max-width: 300px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.1);
        }
        
        .layer-info h3 {
            margin: 0 0 0.5rem 0;
            color: #4fd1c7;
        }
        
        .weight-matrix {
            display: grid;
            gap: 2px;
            margin: 2rem auto;
            justify-content: center;
        }
        
        .weight-cell {
            width: 30px;
            height: 30px;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            font-weight: bold;
            color: white;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
        }
        
        .flow-animation {
            animation: pulse 2s ease-in-out infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 0.3; }
            50% { opacity: 1; }
        }
        
        .gradient-flow {
            animation: gradientFlow 3s ease-in-out infinite;
        }
        
        @keyframes gradientFlow {
            0% { stroke-dashoffset: 0; }
            100% { stroke-dashoffset: -20; }
        }
        
        .heatmap-legend {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 1rem;
            margin: 1rem 0;
        }
        
        .legend-bar {
            width: 200px;
            height: 20px;
            background: linear-gradient(to right, #e74c3c, #f39c12, #f1c40f, #2ecc71);
            border-radius: 10px;
            border: 1px solid rgba(255,255,255,0.3);
        }
        
        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 1rem;
            margin: 1rem 0;
        }
        
        .stat-box {
            background: rgba(255,255,255,0.1);
            padding: 1rem;
            border-radius: 8px;
            text-align: center;
            border: 1px solid rgba(255,255,255,0.2);
        }
        
        .stat-value {
            font-size: 1.5rem;
            font-weight: bold;
            color: #4fd1c7;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>üß† Multi-Perspective Neural Network</h1>
        <p>Explore different layers and viewpoints of neural network visualization</p>
    </div>

    <div class="container">
        <div class="perspective-tabs">
            <div class="tab active" data-layer="architecture">üèóÔ∏è Architecture</div>
            <div class="tab" data-layer="dataflow">‚ö° Data Flow</div>
            <div class="tab" data-layer="weights">üìä Weight Matrix</div>
            <div class="tab" data-layer="learning">üß† Learning</div>
        </div>

        <div class="visualization-container">
            <!-- Architecture Layer -->
            <div class="layer active" id="architecture-layer">
                <div class="layer-info">
                    <h3>üèóÔ∏è Architecture View</h3>
                    <p>Traditional network topology showing nodes and connections. Drag neurons to explore structure.</p>
                </div>
                <div id="graph-container">
                    <!-- SVG graph will be inserted here -->
                </div>
            </div>

            <!-- Data Flow Layer -->
            <div class="layer" id="dataflow-layer">
                <div class="layer-info">
                    <h3>‚ö° Data Flow View</h3>
                    <p>Watch signals propagate through the network. Animated activation flows in real-time.</p>
                </div>
                <div id="flow-container" style="width:100%;height:500px;border:2px solid rgba(255,255,255,0.3);border-radius:12px;background:black;position:relative;">
                    <!-- Flow visualization -->
                </div>
            </div>

            <!-- Weight Matrix Layer -->
            <div class="layer" id="weights-layer">
                <div class="layer-info">
                    <h3>üìä Weight Matrix View</h3>
                    <p>Heatmap representation of connection strengths. Warmer colors = stronger weights.</p>
                </div>
                <div class="heatmap-legend">
                    <span>Weak</span>
                    <div class="legend-bar"></div>
                    <span>Strong</span>
                </div>
                <div id="weight-matrix-container">
                    <!-- Weight matrices will be inserted here -->
                </div>
            </div>

            <!-- Learning Layer -->
            <div class="layer" id="learning-layer">
                <div class="layer-info">
                    <h3>üß† Learning View</h3>
                    <p>Gradient flow and backpropagation visualization. See how the network learns!</p>
                </div>
                <div id="learning-container" style="width:100%;height:500px;border:2px solid rgba(255,255,255,0.3);border-radius:12px;background:#1a1a2e;position:relative;">
                    <!-- Learning visualization -->
                </div>
            </div>
        </div>

        <div class="controls">
            <button onclick="playAnimation()">‚ñ∂Ô∏è Play Animation</button>
            <button onclick="pauseAnimation()">‚è∏Ô∏è Pause</button>
            <button onclick="resetNetwork()">üîÑ Reset</button>
            <button onclick="randomizeWeights()">üé≤ Randomize</button>
            <button onclick="trainStep()">üìà Train Step</button>
        </div>

        <div class="stats">
            <div class="stat-box">
                <div class="stat-value" id="current-layer">Architecture</div>
                <div>Current Layer</div>
            </div>
            <div class="stat-box">
                <div class="stat-value" id="animation-speed">1.0x</div>
                <div>Speed</div>
            </div>
            <div class="stat-box">
                <div class="stat-value" id="network-activity">Active</div>
                <div>Status</div>
            </div>
        </div>
    </div>

    <script>
        let currentLayer = 'architecture';
        let animationRunning = false;
        let svg = null;
        
        // Neural network data
        const networkData = {
            neurons: [
                { id: 'I1', x: 100, y: 150, type: 'input', activation: 0.8 },
                { id: 'I2', x: 100, y: 250, type: 'input', activation: 0.6 },
                { id: 'I3', x: 100, y: 350, type: 'input', activation: 0.4 },
                { id: 'H1', x: 350, y: 180, type: 'hidden', activation: 0.7 },
                { id: 'H2', x: 350, y: 280, type: 'hidden', activation: 0.5 },
                { id: 'O1', x: 600, y: 230, type: 'output', activation: 0.9 }
            ],
            connections: [
                { from: 'I1', to: 'H1', weight: 0.8 },
                { from: 'I1', to: 'H2', weight: 0.3 },
                { from: 'I2', to: 'H1', weight: -0.5 },
                { from: 'I2', to: 'H2', weight: 0.7 },
                { from: 'I3', to: 'H1', weight: 0.2 },
                { from: 'I3', to: 'H2', weight: -0.4 },
                { from: 'H1', to: 'O1', weight: 1.2 },
                { from: 'H2', to: 'O1', weight: -0.8 }
            ]
        };
        
        // Tab switching
        document.querySelectorAll('.tab').forEach(tab => {
            tab.addEventListener('click', () => {
                const targetLayer = tab.dataset.layer;
                switchLayer(targetLayer);
            });
        });
        
        function switchLayer(layerName) {
            // Update tabs
            document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
            document.querySelector(`[data-layer="${layerName}"]`).classList.add('active');
            
            // Update layers
            document.querySelectorAll('.layer').forEach(l => l.classList.remove('active'));
            document.getElementById(`${layerName}-layer`).classList.add('active');
            
            currentLayer = layerName;
            document.getElementById('current-layer').textContent = layerName.charAt(0).toUpperCase() + layerName.slice(1);
            
            // Initialize layer-specific visualization
            initializeLayer(layerName);
        }
        
        function initializeLayer(layerName) {
            switch(layerName) {
                case 'architecture':
                    createArchitectureView();
                    break;
                case 'dataflow':
                    createDataFlowView();
                    break;
                case 'weights':
                    createWeightMatrixView();
                    break;
                case 'learning':
                    createLearningView();
                    break;
            }
        }
        
        function createArchitectureView() {
            const container = document.getElementById('graph-container');
            container.innerHTML = '';
            
            svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            svg.setAttribute('width', '100%');
            svg.setAttribute('height', '100%');
            svg.setAttribute('viewBox', '0 0 800 500');
            svg.style.background = 'white';
            
            // Create neurons and connections
            networkData.connections.forEach(conn => {
                const fromNeuron = networkData.neurons.find(n => n.id === conn.from);
                const toNeuron = networkData.neurons.find(n => n.id === conn.to);
                createConnection(fromNeuron, toNeuron, conn.weight);
            });
            
            networkData.neurons.forEach(neuron => {
                createNeuron(neuron);
            });
            
            container.appendChild(svg);
        }
        
        function createDataFlowView() {
            const container = document.getElementById('flow-container');
            container.innerHTML = '';
            
            const flowSvg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            flowSvg.setAttribute('width', '100%');
            flowSvg.setAttribute('height', '100%');
            flowSvg.setAttribute('viewBox', '0 0 800 500');
            
            // Create flow visualization with animated particles
            networkData.neurons.forEach(neuron => {
                const group = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                
                // Neuron glow effect
                const glow = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                glow.setAttribute('cx', neuron.x);
                glow.setAttribute('cy', neuron.y);
                glow.setAttribute('r', 40);
                glow.setAttribute('fill', getTypeColor(neuron.type));
                glow.setAttribute('opacity', neuron.activation);
                glow.classList.add('flow-animation');
                
                const core = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                core.setAttribute('cx', neuron.x);
                core.setAttribute('cy', neuron.y);
                core.setAttribute('r', 20);
                core.setAttribute('fill', 'white');
                core.setAttribute('stroke', getTypeColor(neuron.type));
                core.setAttribute('stroke-width', '3');
                
                group.appendChild(glow);
                group.appendChild(core);
                flowSvg.appendChild(group);
            });
            
            // Animated flow paths
            networkData.connections.forEach(conn => {
                const fromNeuron = networkData.neurons.find(n => n.id === conn.from);
                const toNeuron = networkData.neurons.find(n => n.id === conn.to);
                
                const path = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                path.setAttribute('x1', fromNeuron.x);
                path.setAttribute('y1', fromNeuron.y);
                path.setAttribute('x2', toNeuron.x);
                path.setAttribute('y2', toNeuron.y);
                path.setAttribute('stroke', conn.weight > 0 ? '#00ff88' : '#ff4444');
                path.setAttribute('stroke-width', Math.abs(conn.weight) * 5);
                path.setAttribute('stroke-dasharray', '10,5');
                path.classList.add('gradient-flow');
                path.setAttribute('opacity', '0.8');
                
                flowSvg.appendChild(path);
            });
            
            container.appendChild(flowSvg);
        }
        
        function createWeightMatrixView() {
            const container = document.getElementById('weight-matrix-container');
            container.innerHTML = '';
            
            // Create weight matrices for each layer
            const layers = [
                { name: 'Input ‚Üí Hidden', from: ['I1', 'I2', 'I3'], to: ['H1', 'H2'] },
                { name: 'Hidden ‚Üí Output', from: ['H1', 'H2'], to: ['O1'] }
            ];
            
            layers.forEach(layer => {
                const matrixDiv = document.createElement('div');
                matrixDiv.innerHTML = `<h3 style="text-align:center;color:#4fd1c7;">${layer.name}</h3>`;
                
                const matrix = document.createElement('div');
                matrix.className = 'weight-matrix';
                matrix.style.gridTemplateColumns = `repeat(${layer.to.length}, 1fr)`;
                matrix.style.gridTemplateRows = `repeat(${layer.from.length}, 1fr)`;
                
                layer.from.forEach(fromId => {
                    layer.to.forEach(toId => {
                        const conn = networkData.connections.find(c => c.from === fromId && c.to === toId);
                        const weight = conn ? conn.weight : 0;
                        
                        const cell = document.createElement('div');
                        cell.className = 'weight-cell';
                        cell.textContent = weight.toFixed(1);
                        cell.style.backgroundColor = getWeightColor(weight);
                        cell.title = `${fromId} ‚Üí ${toId}: ${weight}`;
                        
                        matrix.appendChild(cell);
                    });
                });
                
                matrixDiv.appendChild(matrix);
                container.appendChild(matrixDiv);
            });
        }
        
        function createLearningView() {
            const container = document.getElementById('learning-container');
            container.innerHTML = '';
            
            const learningSvg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            learningSvg.setAttribute('width', '100%');
            learningSvg.setAttribute('height', '100%');
            learningSvg.setAttribute('viewBox', '0 0 800 500');
            
            // Create gradient flow visualization
            networkData.neurons.forEach(neuron => {
                const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                circle.setAttribute('cx', neuron.x);
                circle.setAttribute('cy', neuron.y);
                circle.setAttribute('r', 25);
                circle.setAttribute('fill', 'none');
                circle.setAttribute('stroke', '#ff6b6b');
                circle.setAttribute('stroke-width', '3');
                circle.setAttribute('stroke-dasharray', '5,5');
                circle.classList.add('gradient-flow');
                
                learningSvg.appendChild(circle);
            });
            
            // Backpropagation arrows
            networkData.connections.forEach(conn => {
                const fromNeuron = networkData.neurons.find(n => n.id === conn.from);
                const toNeuron = networkData.neurons.find(n => n.id === conn.to);
                
                const arrow = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                arrow.setAttribute('x1', toNeuron.x);
                arrow.setAttribute('y1', toNeuron.y);
                arrow.setAttribute('x2', fromNeuron.x);
                arrow.setAttribute('y2', fromNeuron.y);
                arrow.setAttribute('stroke', '#feca57');
                arrow.setAttribute('stroke-width', '2');
                arrow.setAttribute('marker-end', 'url(#gradient-arrow)');
                arrow.setAttribute('opacity', '0.7');
                
                learningSvg.appendChild(arrow);
            });
            
            container.appendChild(learningSvg);
        }
        
        function createNeuron(neuron) {
            const colors = {
                input: '#27ae60',
                hidden: '#3498db',
                output: '#e67e22'
            };
            
            const group = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            group.setAttribute('transform', `translate(${neuron.x}, ${neuron.y})`);
            group.setAttribute('data-neuron-id', neuron.id);
            group.style.cursor = 'move';
            
            const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            circle.setAttribute('r', '25');
            circle.setAttribute('fill', colors[neuron.type]);
            circle.setAttribute('stroke', '#2c3e50');
            circle.setAttribute('stroke-width', '2');
            circle.setAttribute('opacity', 0.3 + neuron.activation * 0.7);
            
            const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            text.setAttribute('text-anchor', 'middle');
            text.setAttribute('dy', '5');
            text.setAttribute('fill', 'white');
            text.setAttribute('font-weight', 'bold');
            text.textContent = neuron.id;
            
            group.appendChild(circle);
            group.appendChild(text);
            
            // Add drag functionality
            addDragBehavior(group, neuron);
            
            svg.appendChild(group);
        }
        
        function createConnection(fromNeuron, toNeuron, weight) {
            const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            line.setAttribute('x1', fromNeuron.x);
            line.setAttribute('y1', fromNeuron.y);
            line.setAttribute('x2', toNeuron.x);
            line.setAttribute('y2', toNeuron.y);
            line.setAttribute('stroke', weight > 0 ? '#27ae60' : '#e74c3c');
            line.setAttribute('stroke-width', Math.abs(weight) * 3 + 1);
            line.setAttribute('opacity', '0.6');
            
            svg.appendChild(line);
        }
        
        function getTypeColor(type) {
            const colors = { input: '#27ae60', hidden: '#3498db', output: '#e67e22' };
            return colors[type] || '#95a5a6';
        }
        
        function getWeightColor(weight) {
            const intensity = Math.abs(weight);
            if (weight > 0) {
                return `rgba(46, 204, 113, ${intensity})`;
            } else {
                return `rgba(231, 76, 60, ${intensity})`;
            }
        }
        
        // Drag functionality for neurons
        function addDragBehavior(element, neuron) {
            let isDragging = false;
            let startX, startY, initialX, initialY;
            
            element.addEventListener('mousedown', (e) => {
                isDragging = true;
                startX = e.clientX;
                startY = e.clientY;
                initialX = neuron.x;
                initialY = neuron.y;
                
                element.style.opacity = '0.8';
                e.preventDefault();
            });
            
            document.addEventListener('mousemove', (e) => {
                if (!isDragging) return;
                
                const deltaX = e.clientX - startX;
                const deltaY = e.clientY - startY;
                
                neuron.x = initialX + deltaX;
                neuron.y = initialY + deltaY;
                
                // Keep neuron within bounds
                neuron.x = Math.max(30, Math.min(neuron.x, 670));
                neuron.y = Math.max(30, Math.min(neuron.y, 370));
                
                element.setAttribute('transform', `translate(${neuron.x}, ${neuron.y})`);
                
                // Update connections
                updateConnections();
            });
            
            document.addEventListener('mouseup', () => {
                if (isDragging) {
                    isDragging = false;
                    element.style.opacity = '1';
                    console.log(`Neuron ${neuron.id} moved to (${neuron.x}, ${neuron.y})`);
                }
            });
            
            // Touch support for mobile
            element.addEventListener('touchstart', (e) => {
                const touch = e.touches[0];
                isDragging = true;
                startX = touch.clientX;
                startY = touch.clientY;
                initialX = neuron.x;
                initialY = neuron.y;
                element.style.opacity = '0.8';
                e.preventDefault();
            });
            
            document.addEventListener('touchmove', (e) => {
                if (!isDragging) return;
                
                const touch = e.touches[0];
                const deltaX = touch.clientX - startX;
                const deltaY = touch.clientY - startY;
                
                neuron.x = initialX + deltaX;
                neuron.y = initialY + deltaY;
                
                neuron.x = Math.max(30, Math.min(neuron.x, 670));
                neuron.y = Math.max(30, Math.min(neuron.y, 370));
                
                element.setAttribute('transform', `translate(${neuron.x}, ${neuron.y})`);
                updateConnections();
                e.preventDefault();
            });
            
            document.addEventListener('touchend', () => {
                if (isDragging) {
                    isDragging = false;
                    element.style.opacity = '1';
                }
            });
        }
        
        // Update all connections when neurons move
        function updateConnections() {
            // Remove existing connection lines
            const lines = svg.querySelectorAll('line');
            lines.forEach(line => line.remove());
            
            // Recreate connections
            networkData.connections.forEach(conn => {
                const fromNeuron = networkData.neurons.find(n => n.id === conn.from);
                const toNeuron = networkData.neurons.find(n => n.id === conn.to);
                if (fromNeuron && toNeuron) {
                    createConnection(fromNeuron, toNeuron, conn.weight);
                }
            });
        }
        
        // Control functions
        function playAnimation() {
            animationRunning = true;
            document.getElementById('network-activity').textContent = 'Animating';
        }
        
        function pauseAnimation() {
            animationRunning = false;
            document.getElementById('network-activity').textContent = 'Paused';
        }
        
        function resetNetwork() {
            initializeLayer(currentLayer);
            document.getElementById('network-activity').textContent = 'Reset';
        }
        
        function randomizeWeights() {
            networkData.connections.forEach(conn => {
                conn.weight = (Math.random() - 0.5) * 2;
            });
            initializeLayer(currentLayer);
        }
        
        function trainStep() {
            // Simulate training step
            networkData.neurons.forEach(neuron => {
                neuron.activation = Math.random();
            });
            initializeLayer(currentLayer);
        }
        
        // Initialize
        initializeLayer('architecture');
    </script>
</body>
</html>
