<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simple MaxGraph Hybrid Demo</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background: #f5f5f5;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        .demo-tabs {
            display: flex;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }
        .tab-button {
            flex: 1;
            padding: 15px;
            background: none;
            border: none;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            color: #666;
            transition: all 0.3s ease;
            border-radius: 8px;
        }
        .tab-button.active {
            background: #4CAF50;
            color: white;
        }
        .demo-content {
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            overflow: hidden;
        }
        .tab-panel {
            display: none;
            padding: 20px;
        }
        .tab-panel.active {
            display: block;
        }
        .graph-container {
            width: 100%;
            height: 500px;
            border: 1px solid #ddd;
            border-radius: 4px;
            position: relative;
            overflow: hidden;
        }
        .controls {
            margin-bottom: 15px;
            display: flex;
            gap: 10px;
            align-items: center;
        }
        button {
            padding: 8px 16px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: background 0.3s ease;
        }
        button:hover {
            background: #45a049;
        }
        .info-panel {
            background: #f9f9f9;
            border: 1px solid #e0e0e0;
            border-radius: 4px;
            padding: 15px;
            margin-top: 15px;
            font-size: 14px;
        }
        .neural-node {
            fill: #4CAF50;
            stroke: #388E3C;
            stroke-width: 2;
            cursor: move;
            transition: all 0.3s ease;
        }
        .neural-node:hover {
            fill: #66BB6A;
            stroke: #2E7D32;
            stroke-width: 3;
        }
        .neural-edge {
            stroke: #666;
            stroke-width: 2;
            fill: none;
        }
        .node-label {
            font-family: Arial, sans-serif;
            font-size: 12px;
            fill: white;
            text-anchor: middle;
            dominant-baseline: central;
            pointer-events: none;
        }
        .status {
            background: #e8f5e8;
            padding: 10px;
            border-radius: 4px;
            margin-bottom: 15px;
            font-weight: bold;
            color: #2e7d32;
        }
    </style>
</head>
<body>
    <div class="container">
        <div style="text-align: center; margin-bottom: 30px;">
            <h1>🔬 MaxGraph Hybrid Neural Network Demo</h1>
            <p>Working demonstration of hybrid approach concepts</p>
        </div>

        <div class="demo-tabs">
            <button class="tab-button active" onclick="showTab('working-demo')">Working Demo</button>
            <button class="tab-button" onclick="showTab('concept')">Hybrid Concept</button>
            <button class="tab-button" onclick="showTab('benefits')">Benefits</button>
        </div>

        <div class="demo-content">
            <!-- Working Demo Tab -->
            <div id="working-demo" class="tab-panel active">
                <div class="status">✅ Demo Status: MaxGraph (@maxgraph/core v0.20.0) installed and ready!</div>
                <h3>Hybrid Concept Demo</h3>
                <div class="controls">
                    <button onclick="addRandomNeuron()">Add Neuron (Custom SVG)</button>
                    <button onclick="addMaxGraphShape()">Add MaxGraph Shape</button>
                    <button onclick="addRandomConnection()">Add Connection</button>
                    <button onclick="simulateLayout()">Auto Layout (MaxGraph Feature)</button>
                    <button onclick="animateNetwork()">Animate</button>
                    <button onclick="resetNetwork()">Reset</button>
                    <button onclick="toggleLayerView()">Toggle Layer View</button>
                </div>
                <div id="working-graph" class="graph-container"></div>
                <div class="info-panel">
                    <strong>🔍 What you're seeing:</strong>
                    <ul>
                        <li>🟡 <strong>Yellow rectangles</strong>: Simulated MaxGraph shapes (standard graph nodes)</li>
                        <li>🔵 <strong>Colored circles</strong>: Custom SVG neural nodes (neural-specific rendering)</li>
                        <li>🎯 <strong>Toggle Layer View</strong>: Shows which rendering layer each shape uses</li>
                        <li>⚙️ <strong>In real hybrid</strong>: MaxGraph handles structure, Custom SVG handles neural visuals</li>
                    </ul>
                    <p><strong>Note:</strong> MaxGraph library is installed! Next step: Replace simulation with real MaxGraph API integration + Rust/WASM backend connection.</p>
                </div>
            </div>

            <!-- Concept Tab -->
            <div id="concept" class="tab-panel">
                <h3>Hybrid Approach Architecture</h3>
                <div style="background: #f0f0f0; padding: 20px; border-radius: 8px; margin: 20px 0;">
                    <pre style="margin: 0; font-family: monospace; font-size: 12px;">
┌─────────────────────────────────────────────────────────┐
│                MaxGraph Engine                          │
│  • Graph structure management                           │
│  • Layout algorithms (hierarchical, organic, etc.)     │
│  • Event handling (drag, select, zoom)                 │
│  • Undo/redo functionality                             │
└─────────────────────┬───────────────────────────────────┘
                      │
┌─────────────────────┴───────────────────────────────────┐
│             JavaScript Coordinator                     │
│  • Bridges MaxGraph events to custom rendering         │
│  • Syncs visual state with computational backend       │
│  • Manages neural-specific interactions                │
└─────────────────────┬───────────────────────────────────┘
                      │
    ┌─────────────────┴─────────────────┐
    │                                   │
┌───▼─────────────────┐    ┌───────────▼──────────────────┐
│  Custom SVG Layer  │    │     Rust/WASM Backend       │
│                     │    │                              │
│ • Neural styling    │    │ • Forward/backward pass      │
│ • Activation shows  │    │ • Gradient computation       │
│ • Weight visualization│  │ • Training algorithms        │
│ • Smooth animations │    │ • High-performance math      │
└─────────────────────┘    └──────────────────────────────┘
                    </pre>
                </div>
                <div class="info-panel">
                    This hybrid architecture gives you MaxGraph's professional features while 
                    maintaining complete control over neural network visualization and computation.
                </div>
            </div>

            <!-- Benefits Tab -->
            <div id="benefits" class="tab-panel">
                <h3>Why Hybrid is Best</h3>
                <table style="width: 100%; border-collapse: collapse; margin: 20px 0;">
                    <thead>
                        <tr style="background: #f0f0f0;">
                            <th style="padding: 12px; border: 1px solid #ddd;">Approach</th>
                            <th style="padding: 12px; border: 1px solid #ddd;">Pros</th>
                            <th style="padding: 12px; border: 1px solid #ddd;">Cons</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td style="padding: 12px; border: 1px solid #ddd;"><strong>Pure SVG</strong></td>
                            <td style="padding: 12px; border: 1px solid #ddd;">
                                ✅ Complete visual control<br>
                                ✅ Neural-specific styling<br>
                                ✅ Custom interactions
                            </td>
                            <td style="padding: 12px; border: 1px solid #ddd;">
                                ❌ Must build graph engine<br>
                                ❌ No layout algorithms<br>
                                ❌ High development time
                            </td>
                        </tr>
                        <tr>
                            <td style="padding: 12px; border: 1px solid #ddd;"><strong>Pure MaxGraph</strong></td>
                            <td style="padding: 12px; border: 1px solid #ddd;">
                                ✅ Professional features<br>
                                ✅ Layout algorithms<br>
                                ✅ Fast development
                            </td>
                            <td style="padding: 12px; border: 1px solid #ddd;">
                                ❌ Limited customization<br>
                                ❌ Generic appearance<br>
                                ❌ Hard to integrate WASM
                            </td>
                        </tr>
                        <tr style="background: #e8f5e8;">
                            <td style="padding: 12px; border: 1px solid #ddd;"><strong>🏆 Hybrid</strong></td>
                            <td style="padding: 12px; border: 1px solid #ddd;">
                                ✅ Best of both worlds<br>
                                ✅ Professional + Custom<br>
                                ✅ Easy WASM integration<br>
                                ✅ Future-proof architecture
                            </td>
                            <td style="padding: 12px; border: 1px solid #ddd;">
                                ⚠️ Initial setup complexity<br>
                                ⚠️ Need to understand both systems
                            </td>
                        </tr>
                    </tbody>
                </table>
                <div class="info-panel">
                    <strong>Recommendation:</strong> The hybrid approach is optimal for professional neural network tools.
                    You get MaxGraph's maturity with complete visual and computational control.
                </div>
            </div>
        </div>
    </div>

    <script>
        // Simple hybrid demo implementation
        let neurons = [];
        let connections = [];
        let maxGraphShapes = []; // Separate array for MaxGraph shapes (ready for real API)
        let svg = null;
        let neuronIdCounter = 1;
        let maxGraphIdCounter = 1;
        let isDragging = false;
        let dragNeuron = null;
        let showLayers = false; // Toggle to show which layer is which
        let startX, startY, initialX, initialY; // Move these to global scope

        // Initialize the working demo
        function initWorkingDemo() {
            const container = document.getElementById('working-graph');
            
            // Create SVG
            svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            svg.setAttribute('width', '100%');
            svg.setAttribute('height', '100%');
            svg.style.background = 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)';
            
            // Add initial network
            createInitialNetwork();
            container.appendChild(svg);
        }

        function createInitialNetwork() {
            // Clear existing
            neurons = [];
            connections = [];
            
            // Create sample neurons
            neurons.push({ id: 'I1', x: 100, y: 150, type: 'input', activation: 0.8, label: 'Input 1' });
            neurons.push({ id: 'I2', x: 100, y: 250, type: 'input', activation: 0.6, label: 'Input 2' });
            neurons.push({ id: 'H1', x: 300, y: 200, type: 'hidden', activation: 0.7, label: 'Hidden' });
            neurons.push({ id: 'O1', x: 500, y: 200, type: 'output', activation: 0.9, label: 'Output' });
            
            // Create connections
            connections.push({ from: 'I1', to: 'H1', weight: 0.8 });
            connections.push({ from: 'I2', to: 'H1', weight: 0.6 });
            connections.push({ from: 'H1', to: 'O1', weight: 0.9 });
            
            renderNetwork();
        }

        function renderNetwork() {
            if (!svg) return;
            
            // Clear SVG
            svg.innerHTML = '';
            
            // Render connections first
            connections.forEach(conn => {
                const fromNeuron = neurons.find(n => n.id === conn.from);
                const toNeuron = neurons.find(n => n.id === conn.to);
                if (fromNeuron && toNeuron) {
                    renderConnection(fromNeuron, toNeuron, conn.weight);
                }
            });
            
            // Render neurons
            neurons.forEach(neuron => {
                renderNeuron(neuron);
            });

            // Render MaxGraph shapes
            maxGraphShapes.forEach(shape => {
                renderMaxGraphShape(shape);
            });

            // Add layer backgrounds
            addLayerBackgrounds();
        }

        function renderNeuron(neuron) {
            const colors = {
                input: '#2196F3',
                hidden: '#4CAF50',
                output: '#FF5722'
            };
            
            const group = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            group.setAttribute('data-neuron-id', neuron.id);
            group.style.cursor = 'move';
            
            const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            circle.setAttribute('cx', neuron.x);
            circle.setAttribute('cy', neuron.y);
            circle.setAttribute('r', '25');
            circle.setAttribute('fill', colors[neuron.type]);
            circle.setAttribute('stroke', '#333');
            circle.setAttribute('stroke-width', '2');
            circle.setAttribute('opacity', 0.7 + neuron.activation * 0.3);
            
            const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            text.setAttribute('x', neuron.x);
            text.setAttribute('y', neuron.y + 5);
            text.classList.add('node-label');
            text.textContent = neuron.activation.toFixed(1);
            
            const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            label.setAttribute('x', neuron.x);
            label.setAttribute('y', neuron.y + 45);
            label.setAttribute('text-anchor', 'middle');
            label.setAttribute('fill', 'white');
            label.setAttribute('font-size', '12');
            label.textContent = neuron.label;
            
            // Layer indicator when enabled
            if (showLayers) {
                const layerIndicator = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                layerIndicator.setAttribute('x', neuron.x);
                layerIndicator.setAttribute('y', neuron.y + 60);
                layerIndicator.setAttribute('text-anchor', 'middle');
                layerIndicator.setAttribute('fill', '#009900');
                layerIndicator.setAttribute('font-size', '10');
                layerIndicator.setAttribute('font-style', 'italic');
                layerIndicator.textContent = 'Custom SVG';
                group.appendChild(layerIndicator);
            }
            
            group.appendChild(circle);
            group.appendChild(text);
            group.appendChild(label);
            
            // Add drag functionality
            addDragToNeuron(group, neuron);
            
            // Add click functionality
            group.addEventListener('click', () => {
                neuron.activation = Math.random();
                renderNetwork();
            });
            
            svg.appendChild(group);
        }

        function renderConnection(fromNeuron, toNeuron, weight) {
            const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            line.setAttribute('x1', fromNeuron.x);
            line.setAttribute('y1', fromNeuron.y);
            line.setAttribute('x2', toNeuron.x);
            line.setAttribute('y2', toNeuron.y);
            line.setAttribute('stroke', weight > 0.5 ? '#4CAF50' : '#FF5722');
            line.setAttribute('stroke-width', Math.abs(weight) * 4);
            line.setAttribute('opacity', '0.7');
            line.classList.add('neural-edge');
            
            svg.appendChild(line);
        }

        function addDragToNeuron(element, neuron) {
            element.addEventListener('mousedown', (e) => {
                isDragging = true;
                dragNeuron = neuron;
                startX = e.clientX;
                startY = e.clientY;
                initialX = neuron.x;
                initialY = neuron.y;
                element.style.opacity = '0.8'; // Visual feedback
                e.preventDefault();
                e.stopPropagation();
            });
        }

        function addMaxGraphShape() {
            const newShape = {
                id: `MG${maxGraphIdCounter++}`,
                x: 150 + Math.random() * 300,
                y: 150 + Math.random() * 200,
                type: 'maxgraph-rect',
                label: `MaxGraph ${maxGraphIdCounter - 1}`
            };
            
            maxGraphShapes.push(newShape);
            renderNetwork();
        }

        function renderMaxGraphShape(shape) {
            const group = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            group.setAttribute('data-maxgraph-id', shape.id);
            group.style.cursor = 'move';
            
            // MaxGraph-style rectangle (simulating MaxGraph rendering)
            const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
            rect.setAttribute('x', shape.x - 40);
            rect.setAttribute('y', shape.y - 15);
            rect.setAttribute('width', '80');
            rect.setAttribute('height', '30');
            rect.setAttribute('fill', '#f0f0f0');
            rect.setAttribute('stroke', '#666');
            rect.setAttribute('stroke-width', '1');
            rect.setAttribute('rx', '3');
            
            const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            text.setAttribute('x', shape.x);
            text.setAttribute('y', shape.y + 5);
            text.setAttribute('text-anchor', 'middle');
            text.setAttribute('fill', '#333');
            text.setAttribute('font-size', '12');
            text.textContent = shape.label;
            
            // Layer indicator when enabled
            if (showLayers) {
                const layerIndicator = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                layerIndicator.setAttribute('x', shape.x);
                layerIndicator.setAttribute('y', shape.y - 25);
                layerIndicator.setAttribute('text-anchor', 'middle');
                layerIndicator.setAttribute('fill', '#666');
                layerIndicator.setAttribute('font-size', '10');
                layerIndicator.setAttribute('font-style', 'italic');
                layerIndicator.textContent = 'MaxGraph Layer';
                group.appendChild(layerIndicator);
            }
            
            group.appendChild(rect);
            group.appendChild(text);
            
            // Add drag functionality for MaxGraph shapes too
            addDragToMaxGraphShape(group, shape);
            
            svg.appendChild(group);
        }

        function addDragToMaxGraphShape(element, shape) {
            element.addEventListener('mousedown', (e) => {
                isDragging = true;
                dragNeuron = shape; // Reuse same drag logic
                startX = e.clientX;
                startY = e.clientY;
                initialX = shape.x;
                initialY = shape.y;
                element.style.opacity = '0.8';
                e.preventDefault();
                e.stopPropagation();
            });
        }

        function toggleLayerView() {
            showLayers = !showLayers;
            renderNetwork();
        }

        function addLayerBackgrounds() {
            // Add background to show MaxGraph layer
            const maxGraphBg = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
            maxGraphBg.setAttribute('x', '10');
            maxGraphBg.setAttribute('y', '10');
            maxGraphBg.setAttribute('width', '280');
            maxGraphBg.setAttribute('height', '480');
            maxGraphBg.setAttribute('fill', 'rgba(255, 255, 0, 0.1)');
            maxGraphBg.setAttribute('stroke', '#ffcc00');
            maxGraphBg.setAttribute('stroke-width', '2');
            maxGraphBg.setAttribute('stroke-dasharray', '5,5');
            maxGraphBg.setAttribute('rx', '5');
            
            const maxGraphLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            maxGraphLabel.setAttribute('x', '20');
            maxGraphLabel.setAttribute('y', '30');
            maxGraphLabel.setAttribute('fill', '#cc9900');
            maxGraphLabel.setAttribute('font-size', '12');
            maxGraphLabel.setAttribute('font-weight', 'bold');
            maxGraphLabel.textContent = 'MaxGraph Layer (Graph Engine)';
            
            // Add background to show Custom SVG layer
            const customBg = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
            customBg.setAttribute('x', '310');
            customBg.setAttribute('y', '10');
            customBg.setAttribute('width', '280');
            customBg.setAttribute('height', '480');
            customBg.setAttribute('fill', 'rgba(0, 255, 0, 0.1)');
            customBg.setAttribute('stroke', '#00cc00');
            customBg.setAttribute('stroke-width', '2');
            customBg.setAttribute('stroke-dasharray', '5,5');
            customBg.setAttribute('rx', '5');
            
            const customLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            customLabel.setAttribute('x', '320');
            customLabel.setAttribute('y', '30');
            customLabel.setAttribute('fill', '#009900');
            customLabel.setAttribute('font-size', '12');
            customLabel.setAttribute('font-weight', 'bold');
            customLabel.textContent = 'Custom SVG Layer (Neural Rendering)';
            
            svg.appendChild(maxGraphBg);
            svg.appendChild(maxGraphLabel);
            svg.appendChild(customBg);
            svg.appendChild(customLabel);
        }

        // Global mouse events for dragging
        document.addEventListener('mousemove', (e) => {
            if (!isDragging || !dragNeuron) return;
            
            const deltaX = e.clientX - startX;
            const deltaY = e.clientY - startY;
            
            dragNeuron.x = Math.max(30, Math.min(initialX + deltaX, 570));
            dragNeuron.y = Math.max(30, Math.min(initialY + deltaY, 470));
            
            renderNetwork();
        });

        document.addEventListener('mouseup', () => {
            if (isDragging) {
                isDragging = false;
                dragNeuron = null;
                // Reset visual feedback for all neurons
                const neuronGroups = svg.querySelectorAll('g[data-neuron-id]');
                neuronGroups.forEach(group => {
                    group.style.opacity = '1';
                });
            }
        });

        // Control functions
        function addRandomNeuron() {
            const types = ['input', 'hidden', 'output'];
            const type = types[Math.floor(Math.random() * types.length)];
            const newNeuron = {
                id: `N${neuronIdCounter++}`,
                x: 100 + Math.random() * 400,
                y: 100 + Math.random() * 300,
                type: type,
                activation: Math.random(),
                label: `${type.charAt(0).toUpperCase() + type.slice(1)} ${neuronIdCounter - 1}`
            };
            
            neurons.push(newNeuron);
            renderNetwork();
        }

        function addRandomConnection() {
            if (neurons.length < 2) return;
            
            const from = neurons[Math.floor(Math.random() * neurons.length)];
            const to = neurons[Math.floor(Math.random() * neurons.length)];
            
            if (from.id !== to.id) {
                // Check if connection already exists
                const exists = connections.some(c => 
                    (c.from === from.id && c.to === to.id) || 
                    (c.from === to.id && c.to === from.id)
                );
                
                if (!exists) {
                    connections.push({
                        from: from.id,
                        to: to.id,
                        weight: Math.random()
                    });
                    renderNetwork();
                }
            }
        }

        function simulateLayout() {
            // Simple layout algorithm - arrange by type
            const inputNeurons = neurons.filter(n => n.type === 'input');
            const hiddenNeurons = neurons.filter(n => n.type === 'hidden');
            const outputNeurons = neurons.filter(n => n.type === 'output');
            
            // Arrange inputs on left
            inputNeurons.forEach((neuron, i) => {
                neuron.x = 100;
                neuron.y = 100 + (i * 80);
            });
            
            // Arrange hidden in middle
            hiddenNeurons.forEach((neuron, i) => {
                neuron.x = 300;
                neuron.y = 100 + (i * 80);
            });
            
            // Arrange outputs on right
            outputNeurons.forEach((neuron, i) => {
                neuron.x = 500;
                neuron.y = 100 + (i * 80);
            });
            
            renderNetwork();
        }

        function animateNetwork() {
            // Animate activations
            let step = 0;
            const animate = () => {
                neurons.forEach(neuron => {
                    neuron.activation = 0.5 + 0.5 * Math.sin(step * 0.1 + Math.random());
                });
                renderNetwork();
                step++;
                
                if (step < 50) {
                    requestAnimationFrame(animate);
                }
            };
            animate();
        }

        function resetNetwork() {
            createInitialNetwork();
        }

        // Tab switching
        function showTab(tabName) {
            // Hide all panels
            document.querySelectorAll('.tab-panel').forEach(panel => {
                panel.classList.remove('active');
            });
            
            // Remove active class from all buttons
            document.querySelectorAll('.tab-button').forEach(button => {
                button.classList.remove('active');
            });
            
            // Show selected panel and activate button
            document.getElementById(tabName).classList.add('active');
            event.target.classList.add('active');
        }

        // Initialize when page loads
        document.addEventListener('DOMContentLoaded', function() {
            initWorkingDemo();
        });
    </script>
</body>
</html>
